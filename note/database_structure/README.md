# Oracle DB的定義
### Oracle 關係型數據庫管理系統(Relational Database Management System)
- 關係模型 
	- 使用二維表來存取數據
- 數據庫 
	- 存儲二維表數據的文件
- 管理系統 
	- 軟體讓我們能夠對數據庫進行曾刪改查
# Oracle DB體系結構概覽
### 關係型數據庫管理系統包含三個部分
- Hardware
- Software
- Data
### 服務器Server (Hardware) 
- 給數據庫軟體分配 CPU 內存
	- 內存結構
		- 專用名稱叫做系統全局區(System Global Area)
- 進程把硬碟的數據讀入內存,把內存中更新過的數據寫入文件中
	- 進程結構
		- 進程有負責寫數據的,有負責讀數據的,有負責檢查數據的,有負責監控的
- 數據以二維表的形式儲存文件
	- 存儲結構
		- 數據庫
### 數據庫兩個概念,數據庫是以這兩部分組成 
- 實例(instance) 
	- 操作系統給數據庫分配的內存與數據庫所使用的進程 (內存+進程)
- 數據庫(database) 
	- 儲存數據文件
### 客戶端Client (Software) 
- 用戶發起增刪改查的請求會啟動用戶進程 
	- 用戶進程蒐集用戶的SQL請求,然後發送給服務器
- 服務器啟動服務器進程來接收用戶的請求
	- 服務器進程將數據庫處理完畢的結果發送給用戶
- 服務器進程需要內存結構PGA,與SGA市區分開的
### 內存結構
- 分為SGA跟PGA
- 內存結構內分為很多區域,每個區域都有自己獨立的功能
	- 比如SGA內有 
		- 緩存SQL語句
		- 緩存數據(DATA)
		- 執行JAVA代碼
		- 做流(Stream)複製用
		- I/O
		- 日誌(log)
	- PGA裡面則是放跟用戶有關的,比如
		- 用戶的數據
		- 用戶發起的SQL
		- 用戶檢索到的數據
### SGA的作用
- 當用戶執行SQL語句 -> 數據庫拿到語句後要先進行分析 -> 將分析的步驟編譯為二進制的代碼 -> 然後放到CPU去執行
	- 分析比如 
		- SQL語句要訪問的對象
		- 哪個用戶發起的請求
		- 這個用戶有沒有操作這個對象的權限
		- 是做增刪改查的哪一個呢
		- 這個對象(object)是否存在
		- 有多少行多少列呢
- SGA內存內的區域作用
	- 緩存SQL語句的區域 
		- 相同語句能共享給所有用戶
		- 執行需要
			- 時間
 			- 資源(resource)
		- 當另外一個用戶執行相同的語句就可以從緩存SQL的內存中將結果發給此用戶,而不用經過分析,編譯
	- 緩存數據的區域
		- 儲存經常訪問的數據(hot data)
		- 經常被訪問的數據會駐留在這個內存中,這樣當再次被訪問後就沒必要從硬碟去讀取了
		- 硬碟(HDD) 讀寫的速度與內存(RAM)有很大的差別
			- 硬碟一般讀寫速度為100MB/s
			- 內存一般讀寫速度為10GB/s
		- 設計數據庫
			- 盡量讓所有的訪問與操作在內存中執行
			- 避免訪問數據時去訪問硬碟
			- 避免往硬碟裡面去讀寫
- SGA的特點是被所有用戶共享
### PGA的作用
- 當用戶執行SQL語句由用戶進程蒐集然後發給服務器進程,這時服務器進程就需要一個區域去儲存原始的SQL
- 當數據庫把結果(result)返回時也需要一個區域來儲存結果
- PGA是不被其他用戶去共享,每個人操作時都有一個獨立的服務器進程,每個服務器進程都有一個獨立的內存區(PGA)
### 多層體系結構
- C/S架構(Client/Server) 客戶端<------------>服務器
	- 客戶端直接對服務器發起請求
	- 客戶端部屬軟體工作量大
	- 大量用戶訪問服務器會造成數據庫需要使用大量的資源去接受,分析,處理,返回客戶端所發出的請求
- B/S架構(Browser/Server) 客戶端<-->中間層<-->服務器
	- 解決大併發,大量的用戶的問題
	- 以瀏覽器來訪問系統
	- 客戶端不需要部屬軟體
	- 中間層 
		- 用來接收用戶發起的請求
		- 做的工作
			- 應用程序上的邏輯上的運算
			- 如果客戶端發起的是數據的請求,轉發數據的操作請求
			- 緩存數據
				- 用戶操作數據
				- 數據庫返還的數據
		- 有時候這個中間層也可以被叫作應用層,通常是以一些應用服務器來構成的
- 數據庫位於架構的最後方,是安全級別最高的,被防火牆層層保護,從客戶端到中間層有防火牆,從中間層到數據庫也有防火牆,為了保護數據安全
### 實例(instance)與數據庫配置(Database Configurrations)的關係
- 服務器帶有本地的存儲
	- 存儲可以是服務器裡的硬碟
	- 可以是專門的設備
		- FC San
		- NFS
		- ASM
		- RAW
- 非集群環境(Nonclustered System)
	- 一台服務器對應一個本地存儲
	- 創建好數據庫後,啟動數據庫就生成了一個實例(內存+進程)
	- 如果有保存數據,那在本地存儲會生成一個數據庫(文件)
	- 這樣就可以用實例來操縱數據庫裡面的文件
	- 如果需要第二個數據庫,我們可以直接在服務器中再創建一個實例讓他對應一個新的數據庫
	- 所以一個服務器裡可以創建多個實例,在存儲上也能夠有多個數據庫,但是每一個實例只能操作一個數據庫,是一對一的關係
	- 一台服務器上裝多個數據庫,每個數據庫上都有自己專有的實例來操作
- 集群環境(Clustered System)
	- 多台服務器對應一個共享存儲
	- 通過硬體的手段或者軟體的手段實現共同訪問一個存儲區
	- 每一台服務器上都有實例但是他們訪問的是同一個數據庫,這就是多實例對單數據庫,是多對一的關係
	- 每個實例可以同時對同一張表進行增刪改查,而這種併發的問題有一個鎖(Lock)的機制來管理
	- 這種結構非常安全,要是集群中有服務器故障,只要還有一個服務器在正常運行,用戶還是能正常運用數據庫,因此安全性就提升了
	- 一個數據庫放到一個共享的存儲上,多台服務器分別啟動多個實例去操作同一個數據庫
### 連接到數據庫的概念
- 用戶發起一個數據庫操作的過程
	- 用戶啟動客戶端
	- 用戶執行SQL語句
	- 客戶端啟動用戶進程(User process)
	- 用戶進程將SQL語句蒐集
	- 用戶進程去聯繫數據庫服務器
	- 如果有聯繫成功則服務器啟動服務器進程(Server process)
	- 服務器進程給用戶進程執行一對一的服務
	- 服務器進程處理用戶進程發過來的SQL的請求
	- 服務器進程將請求交由服務器去執行
	- 服務器執行完後就將執行結果返還回去
- 用戶進程與服務器進程之間的通訊叫作連接(connection)
- 從用戶發起SQL到返還結果的一整個過程叫作會話(session)
- 會話有一個生命週期,從用戶連近來進行操作到得到結果,這個會話就完成了,如果再發起一個操作再得到一個結果,這又是一個會話
# 內存結構
### SGA分成的區域
- Shared pool
	- 用來緩存sql
- Database buffer cache
	- 用來緩存熱點數據
- Redo log buffer cache
	- 用來寫日誌
- Large pool
	- 用來提供大的I/O操作
- Java pool
	- 用來執行Java代碼
- Streams pool 
	- 用來做流複製
- KEEP buffer
- RECYCLE buffer
- nK buffer cache
### PGA分成的區域
- Stack Space
	- 用來緩存執行後返還的結果
- User Global Area
	- 用來緩存用戶發起的SQL語句
### 共享池(Shared pool) 
- 同樣也被分成了幾個區域 
	- Library cache 庫緩存
	- Shared SQL area 共享SQL區域
	- Data dictionary cache 數據字典高速緩存
	- Fixed Area 控制組件
	- Other 其他 
- Shared SQL area 
	- SQL被分析完後還要編譯為二進制語言,這個過程要大量開銷CPU,因此為了提升效率,這個區域會緩存經常使用的SQL的
- Data dictionary cache 
	- 數據字典保存了表的定義,用戶的定義,用戶的權限,而分析一條SQL語句就要多次的訪問數據字典
	- 數據字典保存在數據庫中,而數據庫文件是保存在硬碟上的,硬碟的讀取速度是很慢的,因此要將經常訪問的數據字典緩存到內存中
### 數據庫緩衝區高速緩存(Database buffer cache) 
- 與其他緩存區一樣,將經常使用的數據緩存到內存中以減少對硬碟的I/O,使效率大大的提升
- 塊(block)這個概念是為了減少I/O而設計的,而數據庫的設計核心思想就是提高併發,減少I/O,來提升數據庫的性能
- 塊這個概念是為了防止用戶的大量小I/O而設計的,每次讀取一定數量的數據到內存中,這樣用戶操作數據庫時,可能數據已經被儲存到內存中了
- 塊這個概念是做一次I/O最小的單位(minimum unit),一般大小為8KB
### 重作日誌緩衝區(Redo log buffer) 
- 這個區域的特點 
	- 空間小
	- 循環寫
	- 順序寫
- 從第一行開始按順序寫入數據,當空間寫滿後,重新從第一行開始寫,寫之前將那一行的資料全清空,因此可以無限循環寫入資料
- 存放對數據庫所做的更改信息,記錄對數據庫所有的更改,這樣就能將錯誤的地方糾正出來
- 包含重做條目,包含由DML和DDL等操作進行的重做更改的相關信息
- 這些都會對數據庫造成數據的變更,這些變更會被日誌以特殊的結構給記錄下來,這種紀錄日誌的條目,就叫作重做條目
- 數據庫裡面是這樣紀錄重做日誌的
	- 何時
	- 何人
	- 何對象
	- 做何操作
- 要是哪天操作失敗,只要有這些信息,就可以有機會返回到失敗前,因此這個日誌緩衝區就是為了做事務恢復的
### 大池(Large pool) 
- 同樣也被分成了幾個區域
	- I/O Buffer I/O的緩存
	- Free memory 空閒的內存
	- Parallel Query 並行查詢
	- Response queue 響應對列
	- Request queue 請求對列
	- Advanced Queuing 高級對列
- 為以下內容提供大型內存分配
	- 共享服務器的會話和Oracle XA接口
		- 響應對列 - 接收數據庫執行完的大量請求的結果
		- 請求對列 - 接收大量用戶發送的請求
	- I/O服務器進程
	- Oracle DB的備份與還原操作
### Java池(Java pool)和流池(Stream pool) 
- Java池是JVM工作的內存,這個內存區可以執行一些Java的代碼和數據
- 流池主要功能是做流複製,可以複製一些數據到其他服務器中
- 流池還能執行以下操作
	- 儲存對列的緩衝
	- 為相關進程提供內存

# 進程結構
### 進程體系結構
- User processes
	- 當客戶端連接到數據庫時啟動
- Database processes
	- 服務器進程:可以連接到實例,在用戶建立會話時啟動,是一對一的對用戶提供數據服務
	- 後臺進程:實例中的核心進程,當後臺進程崩潰時,會造成整個實例都崩潰,在啟動實例時啟動,實例關閉後才消失,進程包括:
		- 監視進程
			- 監視數據庫運行的狀態,有監視系統的(SMON),還有監視進程的(PMON)
		- 日誌寫進程(LGWR)
			- 每一個變更要寫重做日誌
		- 檢查進程(CKPT)
			- 保持數據的一制性
		- 數據寫進程(DBW)
			- 從內存中往硬碟中寫數據的
- Daemon/Application processes
	- 網路監聽(Listener)
		- 聽哪些用戶在訪問服務器
	- Grid守護進程
		- 一個框架,為我們提供了ASM存儲的組件,管理組件
### 進程結構
- 實例包含了後臺進程(Background processes)與服務器進程(Server processes)
	- 後臺進程有
		- 必須的(Required): 數據寫進程(DBWn),檢查進程(CKPT),日誌寫進程(LGWR),系統監視進程(SMON),進程監視進程(PMON),恢復進程(RECO)
		- 可選的(Optional): 歸檔進程(ARCn),與ASM有關的進程(ASMB,RBAL),Others
- Grid框架進程(Grid Infrastructure Processes)
	- ohas
	- ocssd
	- diskmon
	- orarootagent
	- oraagent
	- cssdagent
- 監聽器(Listener)
	- 當用戶想要訪問服務器,他們之間的連接是靠監聽器連接的
	- 當用戶進程發起了訪問數據庫的請求,監聽器就會幫用戶進程與服務器進程建立連接
	- 當用戶發起訪問非其允許使用的資料庫時,監聽器無法識別時則無法建立連接
### 數據庫寫進程(DBWn) 
- n代表數字,代表有多個同時存在,n數字是從0開始,也就是說第一個是DBW0,設置DBW數量是取決於服務器有幾顆CPU,最多可啟動20個DBWn,從DBW0至DBW9,及DBWa至DBWj
- 這個進程是為了將經過修改的塊(髒塊)寫入數據文件中
	- 髒塊
		- 在內存中比硬碟內的數據塊還新的塊
	- 為了保證硬碟與緩衝區中的數據一致,要將這些髒塊做處理,要將他們寫進數據文件裡
	- 這個過程有兩種方式
		- 異步執行 
			- 在執行其他處理時執行
			- 不是實時執行而是攢到一定程度後才寫一次,這樣可以減少對硬碟的I/O
		- 定期執行
			- 數據庫會定期往數據文件中寫入髒塊
			- 有時候數據修改的少了,沒辦法異步執行時,就會需要定期執行了
	- 數據緩衝區高速緩存的內存不夠使用後會觸發異步執行,將較早修改的髒塊先寫入數據文件然後擦除來騰出空間給其他修改
### 日誌寫進程(LGWR)
- 將重作日誌緩衝區寫入硬碟上的重做日誌文件中
	- 直到LGWR成功地將重做信息(包括提交記錄)寫入重做日誌文件,才能認為事務已經完成
	- 直到LGWR已經寫入重做信息,才可以通過DBWn將緩衝區緩存中的髒緩衝區寫入數據文件
	- 如果分組重做日誌文件,並且組中一個多元復用的重做日誌文件已經損壞,則LGWR將寫入其它組成員,並在警告日誌文件中記錄錯誤
- 重作日誌緩衝區的特點
	- 這個日誌非常重要,每當數據產生變化,都要將其變化紀錄下來,用來檢查操作是否成功,若是沒成功就用日誌中紀錄的過程在執行一次
	- 容量小
	- 可循環使用
	- 紀錄重做信息
		- 重作先寫,才能改變數據,不然要是先改變數據,要是失敗,就沒有挽回的餘地了
- 這個進程會在以下情況下執行操作
	- 重作日誌緩衝區容量小,又是循環使用的,要是寫滿了就要將舊的日誌清空,因此需要在滿之前將日誌寫入文件中,所以這個區域有個規定,當區域寫滿1/3就要將這1/3寫入硬碟中
	- 用戶進程提交事務處裡時(Commit或Rollback)
	- 在DBWn進程將修改過的緩衝區寫入硬碟之前
		- 因為硬碟很容易損壞,要是寫髒塊時失敗了,就要重新寫,但由於硬碟I/O速度慢,有可能在寫完前就將緩衝區的資料清空了,這時候要是這個髒塊相對應的日誌已經被寫進硬碟後,就能以日誌的紀錄重新執行了
	- 每隔3秒執行一次
### 檢查點進程(CKPT)
- 幫助減少實例恢復所需的時間量
- 檢查點信息紀錄在
	- 控制文件
		- 數據庫如果沒有了這個文件,是沒法運行的,是一個非常重要的文件,這個文件記錄了以下幾點
			- 結構的信息
				- 數據庫有多少個重做日誌,多少個數據文件,還有什麼文件,保存的位址,文件的大小這些信息都保存在這裡
			- 變化的信息
				- 紀錄數據庫信息變化的時間System change number
			- 備份的信息
			- 檢查點信息
	- 每個數據文件頭
- 檢查點進程就是調用DBWn進程把髒塊寫到數據文件中,為了讓內存跟硬碟中的數據保持一致,而當髒塊被寫入文件時檢查點進程同時也將檢查點信息寫入文件頭
- 檢查點信息也同時被寫入控制文件中,而在控制文件中還要記錄一塊信息,那就是當前時間點的時間,來表示在這一個時間點SCN(System change number)時內存與硬碟中的數據是保持一制的
- 要是突然服務器當機,造成內存數據來不及寫入硬碟裡,此時數據文件還是上一個檢查點的儲存信息,同時控制文件裡記錄的也是上一個檢查點信息,不過裡面紀錄的當前時間點卻是當機時的時間,因此可以查出到底丟失了哪些資料而去使用重做日誌恢復
### 系統監視器進程(SMON)
- 當實例突然故障了,數據丟失了,當實例重新啟動時就需要此進程來執行重做日誌來恢復數據
- 數據庫裡有一些臨時空間來做一些事務,比如說排序,當使用完這些臨時的空間時SMON就會將空間內的數據清除
- 常規任務是定期合併字典管理的表空間中的空閒空間
### 進程監視器進程(PMON)
- 在用戶進程失敗時執行進程恢復
	- 當用戶發起的請求沒有得到結果,也就是用戶進程失敗時,服務器進程就會被PMON清空收回,並且執行恢復
		- 清除數據庫緩衝區高速緩存
			- 因為用戶進程失敗,無法保證用戶執行的修改是正確與否,因此必須要清除掉緩存的數據
		- 釋放用戶進程所使用的資源
			- 為了不佔用資源,所以必須釋放失敗的用戶進程所使用的資源,如CPU或內存
	- 監視會話是否發生空閒會話超時
		- 如果有用戶連接到服務器中卻又不進行操作,這樣會佔用大量的CPU,內存,網路資源,因此如果空閒時間太長PMON就會將連接殺掉來讓其他用戶使用
	- 註冊數據庫服務動態到監聽程序
		- 監聽程序是為了將對數據庫發起請求的用戶正確的連接到數據庫
		- 因為這個監聽程序只負責轉發客戶請求到數據庫中,卻不知道數據庫目前的狀態,因此PMON必須每隔一段時間到監聽程序去註冊一次,讓他知道可以繼續給數據庫發送請求,這個時間的間隔是1分鐘
### 恢復器進程(RECO)
- 用于分布式事務
	- 一個事務被分布在兩個不同的數據庫里
- 自動連接到其他那些與有問題的分佈式事務處理有關的數據庫
	- RECO會負責監視兩邊的數據庫的操作,當一邊的操作失敗,就會把另一邊的操作回滾
- 刪除對應于有問題的事務處裡的所有行
	- 發起端發起遠程操作時會自動起動RECO進程來監視遠程的操作狀態,要是監控到沒完成就回收執行的所有操作
### 歸檔進程(ARCn)
- 支持多個歸檔進程,第一個是ARC0,默認只啟動一個歸檔進程
- 在發生日誌切換之後,將重作日誌文件複製到指定的存儲設備
	- SGA內緩存的大量重作日誌被LGWR進程寫進數據庫的日誌文件中,當日誌文件寫滿後,便會按順序的將最早的文件清空以便寫入新數據,但在清空前會先將日誌文件鎖定,由ARC進程將重作日誌寫進歸檔文件中,這樣就能將所有重作日誌給保存下來
- 可以收集事務處裡重作數據,並將該數據傳輸到備用目標位置
	- ARC進程負責收集主數據庫的重作日誌,然後將這些傳給副數據庫,副數據庫應用這些日誌將所有的事務再重新操作一遍
		- 能使主數據庫跟副數據庫的數據達成一致性
		- 當某天主數據庫不能運作了我們還能切換到副數據庫
### 進程的啟動順序
- 啟動順序
	- 先啟動操作系統
	- 再啟動Grid框架
	- 最後啟動
		- ASM
			- storage service
		- listener
			- network service
		- instance
			- database
- Oracle Grid Infrastructure由操作系統初始化守護程序啟動
	- 先啟動操作系統初始化守護程序
		- init
	- 再啟動Grid Infrastructure包裝腳本
		- init.ohasd(root)
	- 之後啟動Grid Infrastructure守護程序和進程
		- ohasd.bin
		- oraagent.bin
		- orarootagent.bin
		- diskmon.bin
		- cssdagent
		- ocssd.bin
	- 最後啟動實例與程序
		- ASM實例
		- 監聽程序
		- DB實例
		- 用戶定義的應用程序
- Oracle Grid Infrastructure安裝會修改/etc/inittab文件,以確保他能在每次操作系統啟動時在相應的運行級別啟動
# 存儲結構
### 數據庫存儲體系結構
- 數據文件
	- 用戶數據
- 備份文件
	- 數據文件
- 控制文件
	- 檢查點信息
	- 數據庫結構信息
	- 備份信息
- 聯機重作日誌文件
	- 重作日誌
- 歸檔重作日誌文件
	- 聯機重作日誌文件
- 參數文件
	- 數據庫配置與性能有關的參數
- 口令文件
	- sys用戶的密碼
- 預警日誌和跟蹤文件
	- 嚴重的錯誤信息
	- 進程狀態
	- 內存狀態
	- CUP狀態
### 數據文件邏輯結構
- 段、區和塊
- Disk blocks(File System Storage)
	- 操作系統對硬碟進行格式化,將硬碟分成無數個小塊來儲存文件,這些塊的大小不一,一般大小為512byte
- Data blocks
	- 由操作系統的小塊組成的數據塊,大小為8kb,為了提升性能,從硬碟讀取數據會以一個數據塊為最小單位來讀寫數據進內存中
- Extents
	- 由一些連續的數據塊組成的區,大小不固定,需要多少的空間就分配多少區,為了方便空間管理,因為如果使用塊來插入大數據時,會需要大量的空間分配,這樣會浪費大量的時間
- Segment
	- 由儲存著同一類型數據的區組成的段,段對應了數據庫中的表,一張表就是一個段
- Tablespace
	- 段儲存在表空間中,就像是表的文件夾,將同一類型的表放在相同的表空間內,方便管理
### 邏輯和物理數據庫結構
- 邏輯數據庫結構
	- Oracle data block -> Extent -> Segment -> Tablespace -> Database
		- 數據庫最小的I/O單位,多個數據塊(Oracle data block)組成區(Extent)
		- 表(段)空間分配的最小單位,多個區組成段(Segment)
		- 用來儲存數據的二維表,多個段組成表空間(Tablespace)
		- 用來儲存相同類型表的空間,多個表空間組成數據庫(Database)
- 物理數據庫結構
	- Data file
		- 物理上可以看到的文件 Data file,與Tablespace為多對一關係,是為表空間提供空間的,當表空間傭有了空間後就可以將空間往下劃分為段、區和塊,劃分完後便可以往裡面存數據
	- 數據文件又分為多種存儲系統
		- SAN
		- NAS 
		- Exadata
		- File System
		- NFS
		- ASM
		- RAW
# ASM存儲組件
### 自動存儲管理Automatic Storage Management
- 是可移植的高性能集群文件系統
	- 可移植
		- ASM依賴的是Grid框架而不是操作系統
		- 能輕鬆將ASM從一個系統遷移到另一個系統
		- 可以在不同平台做移植
	- 高性能
		- ASM一般被稱為ASM磁碟組,由很多塊磁碟構成
		- 每次寫入數據時,ASM就將數據分割/條帶化(data striping),然後將切分的數據同時寫入到多塊磁碟中
	- 集群文件系統
		- ASM可以將多台Server合再一起使用
- 管理Oracle DB文件
	- Oracle DB文件就放在ASM裡面
	- Oracle DB文件內儲存著大量數據,因此在讀取寫入時I/O越快越好
- 使用ASM Cluster File System(ACFS)
	- ASM用來做存儲用的文件系統
- 管理應用程序的文件
	- ASM不僅僅能儲存數據文件,同時還能儲存其他應用程序的文件
- 將數據分布到各個磁碟中以平衡負載
	- ASM將寫入或讀取操作分散到各個磁碟中同時做
- 建立數據鏡像
	- Oracle提供鏡像來保護數據
- 解決存儲管理難題
### ASM體系結構
- ASM Cluster File System
	- ASM的文件系統,可以保存應用程序的文件 
- ASM Files for Oracle Database
	- 給Oracle管理數據文件使用的區域
- ASM Dynamic Volume Manager
	- 動態卷管理,管理ASM使用的空間
### ASM存儲組件
- Oracle Database datafile 數據庫的數據文件可以儲存到兩個可選擇的空間
	- File system or Raw device 文件系統或裸設備
	- ASM
- ASM disk group <- ASM file <- ASM extent <- ASM allocation unit -> ASM disk -> ASM disk group
	- 多個ASM磁碟(ASM disk)組成一個ASM磁碟組(ASM disk group)
	- ASM磁碟組中儲存著多個ASM文件(ASM file)
	- ASM磁碟格式化後分成多個AU(ASM allocation unit),通常1個為1MB的大小,是ASM中最小的單位
	- 多個AU組成一個區(ASM extent),方便空間分配所設置的邏輯結構
	- 多個ASM區為一個ASM文件提供空間
- ASM文件不會單獨儲存在某一個磁碟中,而是一定儲存在一個磁碟組裡,為了平衡負載,將條帶化的數據分散並同時寫入不同磁碟中
