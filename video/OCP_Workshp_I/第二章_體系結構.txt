Oracle DB的定義
    - Oracle 關係型數據庫管理系統(Relational Database Management System)
	- 關係模型 
	    - 使用二維表來存取數據
	- 數據庫 
	    - 存儲二維表數據的文件
	- 管理系統 
	    - 軟體讓我們能夠對數據庫進行曾刪改查

    - DDL、DML、DCL、DQL
    	- 資料定義語言 DDL(Data Definition Language)
	    - 用來定義資料庫、資料表、檢視表、索引、預存程序、觸發程序、函數等資料庫物件
	    - 可以用來建立、更新、刪除 table,schema,domain,index,view
	    - 常見的指令有：
	        - CREATE 建立資料庫的物件
	        - ALTER 變更資料庫的物件
	    	- DROP 刪除資料庫的物件

    	- 資料操作語言 DML(Data Manipulation Language)
	    - 用來處理資料表裡的資料
	    - 常見的指令有：
	    	- INSERT 新增資料到資料表中
	    	- UPDATE 更改資料表中的資料
	    	- DELETE 刪除資料表中的資料

    	- 資料控制語言 DCL(Data Control Language)
	    - 用來控制資料表、檢視表之存取權限，提供資料庫的安全性
	    - 常見的指令有：
	    	- GRANT 賦予使用者使用權限
	    	- REVOKE 取消使用者的使用權限
	    	- COMMIT 完成交易作業
	    	- ROLLBACK 交易作業異常，將已變動的資料回復到交易開始的狀態

    	- 資料查詢語言 DQL(Data Query Language)
	    - 負責進行資料查詢，不會對資料本身進行修改的語句
	    - 用來查詢資料表裡的資料
	    - 指令只有一個：
	    	- SELECT 選取資料庫中的資料

        - 各類輔助指令：SELECT,FROM,WHERE,GROUP BY,ORDER BY

Oracle DB體系結構概覽
    - 關係型數據庫管理系統包含三個部分
	- Hardware
	- Software
	- Data

    - 服務器Server (Hardware) 
	- 給數據庫軟體分配 CPU 內存
	    - 內存結構 - 專用名稱叫做系統全局區(System Global Area)
	- 進程把硬碟的數據讀入內存,把內存中更新過的數據寫入文件中
	    - 進程結構 - 進程有負責寫數據的,有負責讀數據的,有負責檢查數據的,有負責監控的
	- 數據以二維表的形式存儲在文件
    	    - 存儲結構 - 數據庫

    - 數據庫兩個概念,數據庫是以這兩部分組成 
	- 實例(instance) 
	    - 操作系統給數據庫分配的內存與數據庫所使用的進程 (內存+進程)
	- 數據庫(database) 
	    - 存儲數據的文件

    - 客戶端Client (Software) 
	- 用戶發起增刪改查的請求會啟動用戶進程               
	    - 用戶進程蒐集用戶的SQL請求,然後發送給服務器
    	- 服務器啟動服務器進程來接收用戶的請求
 	    - 服務器進程將數據庫處理完畢的結果發送給用戶
	- 服務器進程需要內存結構PGA,與SGA市區分開的

    - 內存結構分為SGA跟PGA
	- 內存結構內分為很多區域,每個區域都有自己獨立的功能
	    - 比如SGA內有 
		- 緩存SQL語句
		- 緩存數據(DATA)
		- 執行JAVA代碼
		- 做流(Stream)複製用
		- I/O
		- 日誌(log)
	    - PGA裡面則是放跟用戶有關的,比如
		- 用戶的數據
		- 用戶發起的SQL
		- 用戶檢索到的數據

    - SGA的作用
	- 當用戶執行SQL語句 -> 數據庫拿到語句後要先進行分析 -> 將分析的步驟編譯為二進制的代碼 -> 然後放到CPU去執行
	    - 分析比如 
		- SQL語句要訪問的對象
		- 哪個用戶發起的請求
		- 這個用戶有沒有操作這個對象的權限
		- 是做增刪改查的哪一個呢
		- 這個對象(object)是否存在
		- 有多少行多少列呢
	- SGA內存內的區域作用
	    - 緩存SQL語句的區域 
		- 相同語句能共享給所有用戶
	        - 執行需要
		    - 時間
 		    - 資源(resource)
	        - 當另外一個用戶執行相同的語句就可以從緩存SQL的內存中將結果發給此用戶,而不用經過分析,編譯
	    - 緩存數據的區域 - 存儲經常訪問的數據(hot data)
  	        - 經常被訪問的數據會駐留在這個內存中,這樣當再次被訪問後就沒必要從硬碟去讀取了
 	        - 硬碟(HDD) 讀寫的速度與內存(RAM)有很大的差別
		    - 硬碟一般讀寫速度為100MB/s
		    - 內存一般讀寫速度為10GB/s
	        - 設計數據庫
	            - 盡量讓所有的訪問與操作在內存中執行
		    - 避免訪問數據時去訪問硬碟
		    - 避免往硬碟裡面去讀寫
	- SGA的特點是被所有用戶共享

    - PGA的作用
	- 當用戶執行SQL語句由用戶進程蒐集然後發給服務器進程,這時服務器進程就需要一個區域去存儲原始的SQL
	- 當數據庫把結果(result)返回時也需要一個區域來存儲結果
	- PGA是不被其他用戶去共享,每個人操作時都有一個獨立的服務器進程,每個服務器進程都有一個獨立的內存區(PGA)

    -多層體系結構
        - C/S架構(Client/Server) 客戶端<------------>服務器
            - 客戶端直接對服務器發起請求
	    - 客戶端部屬軟體工作量大
	    - 大量用戶訪問服務器會造成數據庫需要使用大量的資源去接受,分析,處理,返回客戶端所發出的請求
        - B/S架構(Browser/Server) 客戶端<-->中間層<-->服務器
	    - 解決大併發,大量的用戶的問題
     	    - 以瀏覽器來訪問系統
	    - 客戶端不需要部屬軟體
	    - 中間層 
		- 用來接收用戶發起的請求
                - 做的工作
		    - 應用程序上的邏輯上的運算
		    - 如果客戶端發起的是數據的請求,轉發數據的操作請求
		    - 緩存數據
			- 用戶操作數據
			- 數據庫返還的數據
		- 有時候這個中間層也可以被叫作應用層,通常是以一些應用服務器來構成的
	- 數據庫位於架構的最後方,是安全級別最高的,被防火牆層層保護,從客戶端到中間層有防火牆,從中間層到數據庫也有防火牆,為了保護數據安全

    - 實例(instance)與數據庫配置(Database Configurrations)的關係
        - 服務器帶有本地的存儲
	    - 存儲可以是服務器裡的硬碟
	    - 可以是專門的設備
		- FC San
		- NFS
		- ASM
		- RAW
        - 非集群環境(Nonclustered System)
	    - 一台服務器對應一個本地存儲
	    - 創建好數據庫後,啟動數據庫就生成了一個實例(內存+進程)
	    - 如果有保存數據,那在本地存儲會生成一個數據庫(文件)
	    - 這樣就可以用實例來操縱數據庫裡面的文件
	    - 如果需要第二個數據庫,我們可以直接在服務器中再創建一個實例讓他對應一個新的數據庫
	    - 所以一個服務器裡可以創建多個實例,在存儲上也能夠有多個數據庫,但是每一個實例只能操作一個數據庫,是一對一的關係
	    - 一台服務器上裝多個數據庫,每個數據庫上都有自己專有的實例來操作
        - 集群環境(Clustered System)
	    - 多台服務器對應一個共享存儲
	    - 通過硬體的手段或者軟體的手段實現共同訪問一個存儲區
	    - 每一台服務器上都有實例但是他們訪問的是同一個數據庫,這就是多實例對單數據庫,是多對一的關係
	    - 每個實例可以同時對同一張表進行增刪改查,而這種併發的問題有一個鎖(Lock)的機制來管理
	    - 這種結構非常安全,要是集群中有服務器故障,只要還有一個服務器在正常運行,用戶還是能正常運用數據庫,因此安全性就提升了
	    - 一個數據庫放到一個共享的存儲上,多台服務器分別啟動多個實例去操作同一個數據庫

    - 連接到數據庫的概念
        - 用戶發起一個數據庫操作的過程
	    - 用戶啟動客戶端
    	    - 用戶執行SQL語句
    	    - 客戶端啟動用戶進程(User process)
    	    - 用戶進程將SQL語句蒐集
    	    - 用戶進程去聯繫數據庫服務器
    	    - 如果有聯繫成功則服務器啟動服務器進程(Server process)
    	    - 服務器進程給用戶進程執行一對一的服務
    	    - 服務器進程處理用戶進程發過來的SQL的請求
    	    - 服務器進程將請求交由服務器去執行
	    - 服務器執行完後就將執行結果返還回去
        - 用戶進程與服務器進程之間的通訊叫作連接(connection)
        - 從用戶發起SQL到返還結果的一整個過程叫作會話(session)
        - 會話有一個生命週期,從用戶連近來進行操作到得到結果,這個會話就完成了,如果再發起一個操作再得到一個結果,這又是一個會話

內存結構
    - SGA分成的區域
	- Shared pool
	    - 用來緩存sql
	- Database buffer cache
	    - 用來緩存熱點數據
	- Redo log buffer cache
	    - 用來寫日誌
	- Large pool
	    - 用來提供大的I/O操作
	- Java pool
	    - 用來執行Java代碼
	- Streams pool 
	    - 用來使用流複製
	- KEEP buffer
	- RECYCLE buffer
	- nK buffer cache

    - PGA分成的區域
	- Stack Space
	    - 用來緩存執行果後返還的結果
	- User Global Area
	    - 用來緩存用戶發起的SQL語句

    - 共享池(Shared pool) 
	- 同樣也被分成了幾個區域 
	    - Library cache 庫緩存
	    - Shared SQL area 共享SQL區域
	    - Data dictionary cache 數據字典高速緩存
	    - Fixed Area 控制組件
	    - Other 其他 
	- Shared SQL area 
	    - SQL被分析完後還要編譯為二進制語言,這個過程要大量開銷CPU,因此為了提升效率,這個區域會緩存經常使用的SQL的
	- Data dictionary cache 
	    - 數據字典保存了表的定義,用戶的定義,用戶的權限,而分析一條SQL語句就要多次的訪問數據字典
	    - 數據字典保存在數據庫中,而數據庫文件是保存在硬碟上的,硬碟的讀取速度是很慢的,因此要將經常訪問的數據字典緩存到內存中

    - 數據庫緩衝區高速緩存(Database buffer cache) 
	- 與其他緩存區一樣,將經常使用的數據緩存到內存中以減少對硬碟的I/O,使效率大大的提升
	- 塊(block)這個概念是為了減少I/O而設計的,而數據庫的設計核心思想就是提高併發,減少I/O,來提升數據庫的性能
	- 塊這個概念是為了防止用戶的大量小I/O而設計的,每次讀取一定數量的數據到內存中,這樣用戶操作數據庫時,可能數據已經被存儲到內存中了
	- 塊這個概念是做一次I/O最小的單位(minimum unit),一般大小為8KB

    - 重作日誌緩衝區(Redo log buffer cache) 
	- 這個區域的特點 
	    - 空間小
	    - 循環寫
	    - 順序寫
	- 從第一行開始按順序寫入數據,當空間寫滿後,重新從第一行開始寫,寫之前將那一行的資料全清空,因此可以無限循環寫入資料
	- 存放對數據庫所做的更改信息,記錄對數據庫所有的更改,這樣就能將錯誤的地方糾正出來
	- 包含重做條目,包含由DML和DDL等操作進行的重做更改的相關信息
	- 這些都會對數據庫造成數據的變更,這些變更會被日誌以特殊的結構給記錄下來,這種紀錄日誌的條目,就叫作重做條目
	- 數據庫裡面是這樣紀錄重做日誌的
	    - 何時
	    - 何人
	    - 何對象
	    - 做何操作
	- 要是哪天操作失敗,只要有這些信息,就可以有機會返回到失敗前,因此這個日誌緩衝區就是為了做事務恢復的

    - 大池(Large pool) 
	- 同樣也被分成了幾個區域
	    - I/O Buffer I/O的緩存
	    - Free memory 空閒的內存
	    - Parallel Query 並行查詢
	    - Response queue 響應對列
	    - Request queue 請求對列
	    - Advanced Queuing 高級對列
	- 為以下內容提供大型內存分配
	    - 共享服務器的會話和Oracle XA接口
		- 響應對列 - 接收數據庫執行完的大量請求的結果
		- 請求對列 - 接收大量用戶發送的請求
	    - I/O服務器進程
	    - Oracle DB的備份與還原操作

    - Java池(Java pool)和流池(Stream pool) 
	- Java池是JVM工作的內存,這個內存區可以執行一些Java的代碼和數據
	- 流池主要功能是做流複製,可以複製一些數據到其他服務器中
	- 流池還能執行以下操作
	    - 存儲對列的緩衝
	    - 為相關進程提供內存

進程結構
    - 進程體系結構
	- User processes
	    - 當客戶端連接到數據庫時啟動
	- Database processes
	    - 服務器進程:可以連接到實例,在用戶建立會話時啟動,是一對一的對用戶提供數據服務
	    - 後臺進程:實例中的核心進程,當後臺進程崩潰時,會造成整個實例都崩潰,在啟動實例時啟動,實例關閉後才消失,進程包括:
		- 監視進程
		    - 監視數據庫運行的狀態,有監視系統的(SMON),還有監視進程的(PMON)
		- 日誌寫進程(LGWR)
		    - 每一個變更要寫重做日誌
		- 檢查進程(CKPT)
		    - 保持數據的一制性
		- 數據寫進程(DBW)
		    - 從內存中往硬碟中寫數據的
	- Daemon/Application processes
	    - 網路監聽(Listener)
	    	- 聽哪些用戶在訪問服務器
	    - Grid守護進程
		- 一個框架,為我們提供了ASM存儲的組件,管理組件

    - 進程結構
	- 實例包含了後臺進程(Background processes)與服務器進程(Server processes)
	    - 後臺進程有
		- 必須的(Required): 數據寫進程(DBWn),檢查進程(CKPT),日誌寫進程(LGWR),系統監視進程(SMON),進程監視進程(PMON),恢復進程(RECO)
		- 可選的(Optional): 歸檔進程(ARCn),與ASM有關的進程(ASMB,RBAL),Others
	- Grid框架進程(Grid Infrastructure Processes)
		- ohas
		- ocssd
		- diskmon
		- orarootagent
		- oraagent
		- cssdagent
        - 監聽器(Listener)
		- 當用戶想要訪問服務器,他們之間的連接是靠監聽器連接的
		- 當用戶進程發起了訪問數據庫的請求,監聽器就會幫用戶進程與服務器進程建立連接
		- 當用戶發起訪問非其允許使用的資料庫時,監聽器無法識別時則無法建立連接

    - 數據庫寫進程(DBWn) 
        - n代表數字,代表有多個同時存在,n數字是從0開始,也就是說第一個是DBW0,設置DBW數量是取決於服務器有幾顆CPU
	    - 這個進程是為了當中經過修改的塊(髒塊)寫入硬碟
	    - 髒塊
		- 在內存中比硬碟內的數據塊還新的塊
	    - 為了保證硬碟與緩衝區中的數據一致,要將這些髒塊做處理,要將他們寫進硬碟裡
	    - 這個過程有兩種方式
	        - 異步執行 
		    - 在執行其他處理時執行
	            - 不是實時執行而是攢到一定程度後才寫一次,這樣可以減少對硬碟的I/O
	        - 定期執行
		    - 數據庫會定期往硬碟中寫入髒塊
		    - 有時候數據修改的少了,沒辦法異步執行時,就會需要定期執行了
	    - 將數據緩衝區高速緩存的內存不夠使用後會觸發異步執行,將較早修改的髒塊先寫入硬碟然後擦除來騰出空間給其他修改

    - 日誌寫進程(LGWR)
        - 將重作日誌緩衝區寫入硬碟上的重做日誌文件中
	- 重作日誌緩衝區的特點
	    - 這個日誌非常重要,每當數據產生變化,都要將其變化紀錄下來,用來檢查操作是否成功,若是沒成功就用日誌中紀錄的過程在執行一次
            - 容量小
	    - 可循環使用
	    - 紀錄重做信息
		- 重作先寫,才能改變數據,不然要是先改變數據,要是失敗,就沒有挽回的餘地了
	- 這個進程會在以下情況下執行操作
	    - 重作日誌緩衝區容量小,又是循環使用的,要是寫滿了就要將舊的日誌清空,因此需要在滿之前將日誌寫入文件中,所以這個區域有個規定,當區域寫滿1/3就要將這1/3寫入硬碟中
            - 用戶進程提交事務處裡時(Commit)
	    - 在DBWn進程將修改過的緩衝區寫入硬碟之前
	        - 因為硬碟很容易損壞,要是寫髒塊時失敗了,就要重新寫,但由於硬碟I/O速度慢,有可能在寫完前就將緩衝區的資料清空了,這時候要是這個髒塊相對應的日誌已經被寫進硬碟後,就能以日誌的紀錄重新執行了
	    - 每隔3秒執行一次

    - 檢查點進程(CKPT)
	- 將檢查點信息紀錄在
	    - 控制文件
		- 數據庫如果沒有了這個文件,是沒法運行的,是一個非常重要的文件,這個文件記錄了以下幾點
		    - 結構的信息
			- 數據庫有多少個重做日誌,多少個數據文件,還有什麼文件,保存的位址,文件的大小這些信息都保存在這裡
		    - 變化的信息
			- 紀錄數據庫信息變化的時間System change number
		    - 備份的信息
		    - 檢查點信息
	    - 每個數據文件頭
	- 檢查點進程就是調用DBWn進程把髒塊寫到數據文件中,為了讓內存跟硬碟中的數據保持一致,而當髒塊被寫入文件時檢查點進程同時也將檢查點信息寫入文件頭
	- 檢查點信息也同時被寫入控制文件中,而在控制文件中還要記錄一塊信息,那就是當前時間點的時間,來表示在這一個時間點SCN(System change number)時內存與硬碟中的數據是保持一制的
	- 要是突然服務器當機,造成內存數據來不及寫入硬碟裡,此時數據文件還是上一個檢查點的儲存信息,同時控制文件裡記錄的也是上一個檢查點信息,不過裡面紀錄的當前時間點卻是當機時的時間,因此可以查出到底丟失了哪些資料而去使用重做日誌恢復

    - 系統監視器進程(SMON)
	- 當實例突然故障了,數據丟失了,當實例重新啟動時就需要此進程來執行重做日誌來恢復數據
        - 數據庫裡有一些臨時空間來做一些事務,比如說排序,當使用完這些臨時的空間時SMON就會將空間內的數據清除

    - 進程監視器進程(PMON)
	- 在用戶進程失敗時執行進程恢復
	    - 當用戶發起的請求沒有得到結果,也就是用戶進程失敗時,服務器進程就會被PMON清空收回,並且執行恢復
	        - 清除數據庫緩衝區高速緩存
		    - 因為用戶進程失敗,無法保證用戶執行的修改是正確與否,因此必須要清除掉緩存的數據
	        - 釋放用戶進程所使用的資源
		    - 為了不佔用資源,所以必須釋放失敗的用戶進程所使用的資源,如CPU或內存
	- 監視會話是否發生空閒會話超時
	    - 如果有用戶連接到服務器中卻又不進行操作,這樣會佔用大量的CPU,內存,網路資源,因此如果空閒時間太長PMON就會將連接殺掉來讓其他用戶使用
	- 註冊數據庫服務動態到監聽程序
	    - 監聽程序是為了將對數據庫發起請求的用戶正確的連接到數據庫
	    - 因為這個監聽程序只負責轉發客戶請求到數據庫中,卻不知道數據庫目前的狀態,因此PMON必須每隔一段時間到監聽程序去註冊一次,讓他知道可以繼續給數據庫發送請求,這個時間的間隔是1分鐘

    - 恢復器進程(RECO)
	- 用于分布式事務
	    - 一個事務被分布在兩個不同的數據庫里
	- 自動連接到其他那些與有問題的分佈式事務處理有關的數據庫
	    - RECO會負責監視兩邊的數據庫的操作,當一邊的操作失敗,就會把另一邊的操作回滾
	- 刪除對應于有問題的事務處裡的所有行
	    - 發起端發起遠程操作時會自動起動RECO進程來監視遠程的操作狀態,要是監控到沒完成就回收執行的所有操作

    - 歸檔進程(ARCn)
	- 支持多個歸檔進程,第一個是ARC0,默認指啟動一個歸檔進程
	- 在發生日誌切換之後,將重作日誌文件複製到指定的存儲設備
	    - SGA內緩存的大量重作日誌被LGWR進程寫進數據庫的日誌文件中,當日誌文件寫滿後,便會按順序的將最早的文件清空以便寫入新數據,但在清空前會先將日誌文件鎖定,由ARC進程將重作日誌寫進歸檔文件中,這樣就能將所有重作日誌給保存下來
	- 可以收集事務處裡重作數據,並將該數據傳輸到備用目標位置
	    - ARC進程負責收集主數據庫的重作日誌,然後將這些傳給副數據庫,副數據庫應用這些日誌將所有的事務再重新操作一遍
		- 能使主數據庫跟副數據庫的數據達成一致性
		- 當某天主數據庫不能運作了我們還能切換到副數據庫

    - 進程的啟動順序
	- 先啟動操作系統 -> 再啟動Grid框架 -> ASM -> storage service
				           -> listener -> network service
				           -> instance -> database
	- Oracle Grid Infrastructure由操作系統初始化守護程序啟動
	    - 操作系統初始化守護程序 -> Grid Infrastructure包裝腳本 -> Grid Infrastructure守護程序和進程 -> ASM實例
		- init                      - init.ohasd(root)  	   - ohasd.bin                   -> 監聽程序
								           - oraagent.bin                -> DB實例
								           - orarootagent.bin            -> 用戶定義的應用程序
								           - diskmon.bin
									   - cssdagent
									   - ocssd.bin
	- Oracle Grid Infrastructure安裝會修改/etc/inittab文件,以確保他能在每次操作系統啟動時在相應的運行級別啟動

存儲結構
    - 數據庫存儲體系結構
	- 數據文件
	    - 用戶數據
	- 備份文件
	    - 數據文件
	- 控制文件
	    - 檢查點信息
	    - 數據庫結構信息
	    - 備份信息
	- 聯機重作日誌文件
	    - 重作日誌
	- 歸檔重作日誌文件
	    - 聯機重作日誌文件
	- 參數文件
	    - 數據庫配置與性能有關的參數
	- 口令文件
	    - sys用戶的密碼
	- 預警日誌和跟蹤文件
	    - 嚴重的錯誤信息
	    - 進程狀態
	    - 內存狀態
	    - CUP狀態

    - 數據文件邏輯結構
	- 段、區和塊
	    - Disk blocks(File System Storage)
		- 操作系統對硬碟進行格式化,將硬碟分成無數個小塊來存儲文件,這些塊的大小不一,一般大小為512byte
	    - Data blocks
		- 由操作系統的小塊組成的數據塊,大小為8kb,為了提升性能,從硬碟讀取數據會以一個數據塊為最小單位來讀寫數據進內存中
	    - Extents
		- 由一些連續的數據塊組成的區,大小不固定,需要多少的空間就分配多少區,為了方便空間管理,因為如果使用塊來插入大數據時,會需要大量的空間分配,這樣會浪費大量的時間
	    - Segment
		- 由存儲著同一類型數據的區組成的段,段對應了數據庫中的表,一張表就是一個段
	    - Tablespace
		- 段儲存在表空間中,就像是表的文件夾,將同一類型的表放在相同的表空間內,方便管理

    - 邏輯和物理數據庫結構
	- 邏輯數據庫結構
	    - Oracle data block -> Extent -> Segment -> Tablespace -> Database
	    - 數據庫最小的I/O單位 Oracle data block,與Extent為多對一關係
	    - 表(段)空間分配的最小單位 Extent,與Segment為多對一關係
	    - 用來存儲數據的二維表 Segment,與Tablespace為多對一關係
	    - 用來存儲相同類型表的空間 Tablespace,與Database為多對一關係
	- 物理數據庫結構
	    - Data file
	    - 物理上可以看到的文件 Data file,與Tablespace為多對一關係,是為表空間提供空間的,當表空間傭有了空間後就可以將空間往下劃分為段、區和塊,劃分完後便可以往裡面存數據
	    - 數據文件又分為多種存儲系統
		- SAN
		- NAS 
		- Exadata
		- File System
		- NFS
		- ASM
		- RAW

ASM存儲組件
    - 自動存儲管理Automatic Storage Management
	- 可移植的
	    - ASM依賴的是Grid框架而不是操作系統
	    - 能輕鬆將ASM從一個系統遷移到另一個系統
	    - 可以在不同平台做移植
	- 高性能
	    - ASM一般被稱為ASM磁碟組,由很多塊磁碟構成
	    - 每次寫入數據,ASM就將數據分成 