Oracle DB的定義
- Oracle 關係型數據庫管理系統(Relational Database Management System)
    - 關係模型 - 使用二維表來存取數據
    - 數據庫 - 存儲二維表數據的文件
    - 管理系統 - 軟體讓我們能夠對數據庫進行曾刪改查

Oracle DB體系結構概覽
    - 關係型數據庫管理系統包含三個部分
	- Hardware
	- Software
	- Data
    - 服務器Server (Hardware) -> 給數據庫軟體分配 CPU 內存
				    - 內存結構 - 專用名稱叫做系統全局區(System Global Area)
			      -> 進程把硬碟的數據讀入內存,把內存中更新過的數據寫入文件中
				    - 進程結構 - 進程有負責寫數據的,有負責讀數據的,有負責檢查數據的,有負責監控的
			      -> 數據以二維表的形式存儲在文件
				    - 存儲結構 - 數據庫
    - 數據庫兩個概念,數據庫是以這兩部分組成 - 實例(instance) - 操作系統給數據庫分配的內存與數據庫所使用的進程 (內存+進程)
		      		            - 數據庫(database) - 存儲數據的文件
    - 客戶端Client (Software) -> 用戶發起增刪改查的請求會啟動用戶進程               
			            - 用戶進程 - 蒐集用戶的SQL請求,然後發送給服務器
    			      -> 服務器啟動服務器進程來接收用戶的請求
 			            - 服務器進程 - 將數據庫處理完畢的結果發送給用戶
			      -> 服務器進程需要內存結構PGA,與SGA市區分開的
    - 內存結構分為SGA跟PGA
	- 內存結構內分為很多區域,每個區域都有自己獨立的功能
	    - 比如SGA內有 - 緩存SQL語句
			  - 緩存數據(DATA)
			  - 執行JAVA代碼
			  - 做流(Stream)複製用
			  - I/O
			  - 日誌(log)
	    - PGA裡面則是放跟用戶有關的,比如 - 用戶的數據
					     - 用戶發起的SQL
					     - 用戶檢索到的數據
    - SGA的作用
	- 當用戶執行SQL語句 -> 數據庫拿到語句後要先進行分析 -> 將分析的步驟編譯為二進制的代碼 -> 然後放到CPU去執行
	    - 分析比如 - SQL語句要訪問的對象
		       - 哪個用戶發起的請求
	 	       - 這個用戶有沒有操作這個對象的權限
		       - 是做增刪改查的哪一個呢
		       - 這個對象(object)是否存在
		       - 有多少行多少列呢
	- SGA內存內的區域作用
	    - 緩存SQL語句的區域 - 相同語句能共享給所有用戶
	        - 執行需要 - 時間
 		           - 資源(resource)
	        - 當另外一個用戶執行相同的語句就可以從緩存SQL的內存中將結果發給此用戶,而不用經過分析,編譯
	    - 緩存數據的區域 - 存儲經常訪問的數據(hot data)
  	        - 經常被訪問的數據會駐留在這個內存中,這樣當再次被訪問後就沒必要從硬碟去讀取了
 	        - 硬碟(HDD) 讀寫的速度與內存(RAM)有很大的差別
		    - 硬碟一般讀寫速度為100MB/s
		    - 內存一般讀寫速度為10GB/s
	        - 設計數據庫
	            - 盡量讓所有的訪問與操作在內存中執行
		    - 避免訪問數據時去訪問硬碟
		    - 避免往硬碟裡面去讀寫
	- SGA的特點是被所有用戶共享
    - PGA的作用
	- 當用戶執行SQL語句由用戶進程蒐集然後發給服務器進程,這時服務器進程就需要一個區域去存儲原始的SQL
	- 當數據庫把結果(result)返回時也需要一個區域來存儲結果
	- PGA是不被其他用戶去共享,每個人操作時都有一個獨立的服務器進程,每個服務器進程都有一個獨立的內存區(PGA)
    -多層體系結構
        - C/S架構(Client/Server) 客戶端<------------>服務器
            - 客戶端直接對服務器發起請求
	    - 客戶端部屬軟體工作量大
	    - 大量用戶訪問服務器會造成數據庫需要使用大量的資源去接受,分析,處理,返回客戶端所發出的請求
        - B/S架構(Browser/Server) 客戶端<-->中間層<-->服務器
	    - 解決大併發,大量的用戶的問題
     	    - 以瀏覽器來訪問系統
	    - 客戶端不需要部屬軟體
	    - 中間層 - 用來接收用戶發起的請求
                     - 做的工作 -> 應用程序上的邏輯上的運算
			        -> 如果客戶端發起的是數據的請求,轉發數據的操作請求
		                -> 緩存數據 - 用戶操作數據
				            - 數據庫返還的數據
		     - 有時候這個中間層也可以被叫作應用層,通常是以一些應用服務器來構成的
	- 數據庫位於架構的最後方,是安全級別最高的,被防火牆層層保護,從客戶端到中間層有防火牆,從中間層到數據庫也有防火牆,為了保護數據安全

實例(instance)與數據庫配置(Database Configurrations)的關係
    - 服務器帶有本地的存儲 - 存儲可以是服務器裡的硬碟
			   - 可以是專門的設備 - FC San
					      - NFS
					      - ASM
					      - RAW
    - 非集群環境(Nonclustered System)
	- 一台服務器對應一個本地存儲
	- 創建好數據庫後,啟動數據庫就生成了一個實例(內存+進程)
	- 如果有保存數據,那在本地存儲會生成一個數據庫(文件)
	- 這樣就可以用實例來操縱數據庫裡面的文件
	- 如果需要第二個數據庫,我們可以直接在服務器中再創建一個實例讓他對應一個新的數據庫
	- 所以一個服務器裡可以創建多個實例,在存儲上也能夠有多個數據庫,但是每一個實例只能操作一個數據庫,是一對一的關係
	- 一台服務器上裝多個數據庫,每個數據庫上都有自己專有的實例來操作
    - 集群環境(Clustered System)
	- 多台服務器對應一個共享存儲
	- 通過硬體的手段或者軟體的手段實現共同訪問一個存儲區
	- 每一台服務器上都有實例但是他們訪問的是同一個數據庫,這就是多實例對單數據庫,是多對一的關係
	- 每個實例可以同時對同一張表進行增刪改查,而這種併發的問題有一個鎖(Lock)的機制來管理
	- 這種結構非常安全,要是集群中有服務器故障,只要還有一個服務器在正常運行,用戶還是能正常運用數據庫,因此安全性就提升了
	- 一個數據庫放到一個共享的存儲上,多台服務器分別啟動多個實例去操作同一個數據庫

連接到數據庫的概念
    - 用戶發起一個數據庫操作的過程
	- 用戶啟動客戶端
    	- 用戶執行SQL語句
    	- 客戶端啟動用戶進程(User process)
    	- 用戶進程將SQL語句蒐集
    	- 用戶進程去聯繫數據庫服務器
    	- 如果有聯繫成功則服務器啟動服務器進程(Server process)
    	- 服務器進程給用戶進程執行一對一的服務
    	- 服務器進程處理用戶進程發過來的SQL的請求
    	- 服務器進程將請求交由服務器去執行
	- 服務器執行完後就將執行結果返還回去
    - 用戶進程與服務器進程之間的通訊叫作連接(connection)
    - 從用戶發起SQL到返還結果的一整個過程叫作會話(session)
    - 會話有一個生命週期,從用戶連近來進行操作到得到結果,這個會話就完成了,如果再發起一個操作再得到一個結果,這又是一個會話

Oracle DB內存結構
    - SGA分成的區域
	- Shared pool - 用來緩存sql
	- Database buffer cache - 用來緩存熱點數據
	- Redo log buffer - 用來寫日誌
	- Large pool - 用來提供大的I/O操作
	- Java pool - 用來執行Java代碼
	- Streams pool - 用來使用流複製
	- KEEP buffer
	- RECYCLE buffer
	- nK buffer cache

    - PGA分成的區域
	- Stack Space - 用來緩存執行果後返還的結果
	- User Global Area - 用來緩存用戶發起的SQL語句
    - 共享池(Shared pool) - 同樣也被分成了幾個區域 - Library cache - 庫緩存
					         - Shared SQL area - 共享SQL區域
						 - Data dictionary cache - 數據字典高速緩存
						 - Fixed Area - 控制組件
						 - Other - 其他
			- Shared SQL area - SQL被分析完後還要編譯為二進制語言,這個過程要大量開銷CPU,因此為了提升效率,這個區域會緩存經常使用的SQL的
			- Data dictionary cache - 數據字典保存了表的定義,用戶的定義,用戶的權限,而分析一條SQL語句就要多次的訪問數據字典
						- 數據字典保存在數據庫中,而數據庫文件是保存在硬碟上的,硬碟的讀取速度是很慢的,因此要將經常訪問的數據字典緩存到內存中
    - 數據庫緩衝區高速緩存(Database buffer cache) - 與其他緩存區一樣,將經常使用的數據緩存到內存中以減少對硬碟的I/O,使效率大大的提升
						- 塊(block)這個概念是為了減少I/O而設計的,而數據庫的設計核心思想就是提高併發,減少I/O,來提升數據庫的性能
						- 塊這個概念是為了防止用戶的大量小I/O而設計的,每次讀取一定數量的數據到內存中,這樣用戶操作數據庫時,可能數據已經被存儲到內存中了
						- 塊這個概念是做一次I/O最小的單位(mini unit),一般大小為8KB
    - 重作日誌緩衝區(Redo log buffer) - 這個區域的特點 - 空間小
						     - 循環寫
						     - 順序寫
				    - 從第一行開始按順序寫入數據,當空間寫滿後,重新從第一行開始寫,寫之前將那一行的資料全清空,因此可以無限循環寫入資料
				    - 存放對數據庫所做的更改信息,記錄對數據庫所有的更改,這樣就能將錯誤的地方糾正出來
				    - 包含重做條目,包含由DML和DDL等操作進行的重做更改的相關信息
					- DML: 對普通的表進行變更的,比如Delete,Update,Insert
					- DDL: 對數據字典的表進行變更的,比如Create,Alter,Drop
				    - 這些都會對數據庫造成數據的變更,這些變更會被日誌以特殊的結構給記錄下來,這種紀錄日誌的條目,就叫作重做條目
				    - 數據庫裡面是這樣紀錄重做日誌的 - 何時
								     - 何人
								     - 何對象
								     - 做何操作
				    - 要是哪天操作失敗,只要有這些信息,就可以有機會返回到失敗前,因此這個日誌緩衝區就是為了做事務恢復的
    - 大池(Large pool) - 同樣也被分成了幾個區域 - I/O Buffer - I/O的緩存
					      - Free memory - 空閒的內存
					      - Parallel Query -並行查詢
					      - Response queue - 響應對列
					      - Request queue - 請求對列
					      - Advanced Queuing - 高級對列
		     - 提供大型內存分配 - I/O服務器進程
					- Oracle DB的備份與還原操作
					- 共享服務器的會話
		     			    - 響應對列 - 接收數據庫執行完的大量請求的結果
					    - 請求對列 - 接收大量用戶發送的請求
					- Oracle XA接口
    - Java池(Java pool)和流池(Stream pool) - Java池是JVM工作的內存,這個內存區可以執行一些Java的代碼和數據
					   - 流池主要功能是做流複製,可以複製一些數據到其他服務器中
				           - 流池還能執行以下操作 - 存儲對列的緩衝
								  - 為相關進程提供內存

Oracle DB進程結構
    - 進程體系結構
	- User processes
	    - 當客戶端連接到數據庫時啟動
	- Database processes
	    - 服務器進程:可以連接到實例,在用戶建立會話時啟動,是一對一的對用戶提供數據服務
	    - 後臺進程:實例中的核心進程,當後臺進程崩潰時,會造成整個實例都崩潰,在啟動實例時啟動,實例關閉後才消失,進程包括:
		- 監視進程 - 監視數據庫運行的狀態,有監視系統的(SMON),還有監視進程的(PMON)
		- 日誌寫進程(LGWR) - 每一個變更要寫重做日誌
		- 檢查進程(CKPT) - 保持數據的一制性
		- 數據寫進程(DBW) - 從內存中往硬碟中寫數據的
	- Daemon/Application processes
	    - 網路監聽(Listener) - 聽哪些用戶在訪問服務器
	    - Grid守護進程 - 一個框架,為我們提供了ASM存儲的組件,管理組件

    - 進程結構
	- 實例包含了後臺進程(Background processes)與服務器進程(Server processes)
	    - 後臺進程有
		- 必須的(Required): 數據寫進程(DBWn),檢查進程(CKPT),日誌寫進程(LGWR),系統監視進程(SMON),進程監視進程(PMON),恢復進程(RECO)
		- 可選的(Optional): 歸檔進程(ARCn),與ASM有關的進程(ASMB,RBAL),Others
	- Grid框架進程(Grid Infrastructure Processes)
		- ohas
		- ocssd
		- diskmon
		- orarootagent
		- oraagent
		- cssdagent
        - 監聽器(Listener)
		- 當用戶想要訪問服務器,他們之間的連接是靠監聽器連接的
		- 當用戶進程發起了訪問數據庫的請求,監聽器就會幫用戶進程與服務器進程建立連接
		- 當用戶發起訪問非其允許使用的資料庫時,監聽器無法識別時則無法建立連接

    - 數據庫寫進程(DBWn) - n代表數字,代表有多個同時存在,n數字是從0開始,也就是說第一個是DBW0,設置DBW數量是取決於服務器有幾顆CPU
			 - 這個進程是為了當中經過修改的塊(髒塊)寫入硬碟
			     - 髒塊 - 在內存中比硬碟內的數據塊還新的塊
			     - 為了保證硬碟與緩衝區中的數據一致,要將這些髒塊做處理,要將他們寫進硬碟裡
			     - 這個過程有兩種方式
			         - 異步執行 - 在執行其他處理時執行
					    - 不是實時執行而是攢到一定程度後才寫一次,這樣可以減少對硬碟的I/O
				 - 定期執行 - 數據庫會定期往硬碟中寫入髒塊
					    - 有時候數據修改的少了,沒辦法異步執行時,就會需要定期執行了
			     - 將數據緩衝區高速緩存的內存不夠使用後會觸發異步執行,將較早修改的髒塊先寫入硬碟然後擦除來騰出空間給其他修改

    - 日誌寫進程(LGWR) - 將重作日誌緩衝區寫入硬碟上的重做日誌文件中
		       - 重作日誌緩衝區的特點 - 這個日誌非常重要,每當數據產生變化,都要將其變化紀錄下來,用來檢查操作是否成功,若是沒成功就用日誌中紀錄的過程在執行一次
		           - 容量小
			   - 可循環使用
			   - 紀錄重做信息 - 重作先寫,才能改變數據,不然要是先改變數據,要是失敗,就沒有挽回的餘地了
		       - 這個進程會在以下情況下執行操作
			   - 重作日誌緩衝區容量小,又是循環使用的,要是寫滿了就要將舊的日誌清空,因此需要在滿之前將日誌寫入文件中,所以這個區域有個規定,當區域寫滿1/3就要將這1/3寫入硬碟中
                           - 用戶進程提交事務處裡時(Commit)
			   - 在DBWn進程將修改過的緩衝區寫入硬碟之前
			       - 因為硬碟很容易損壞,要是寫髒塊時失敗了,就要重新寫,但由於硬碟I/O速度慢,有可能在寫完前就將緩衝區的資料清空了,這時候要是這個髒塊相對應的日誌已經被寫進硬碟後,就能以日誌的紀錄重新執行了
			   - 每隔3秒寫入一次日誌